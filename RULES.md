# FMNetCore 开发规则文档

本文档旨在制定开发规则，避免团队在开发 FMNetCore 项目时重复遇到相同的问题，提高代码质量和开发效率。

## 1. 代码规范规则

### 1.1 命名规范
- 使用清晰、描述性的变量和函数名
- 遵循 Swift API 设计规范
- 协议名使用 "able"、"ible"、"er" 后缀（如 `NetworkInterceptor`）
- 枚举成员使用小写驼峰命名

### 1.2 代码结构
- 每个文件只包含一个主要类型
- 文件长度控制在 500 行以内
- 函数长度控制在 50 行以内
- 避免过深的嵌套层级（建议不超过 3 层）

### 1.3 注释规范
- 所有公共接口必须有文档注释
- 复杂逻辑必须有行内注释
- 注释应说明"为什么"而不是"是什么"

## 2. 网络请求规则

### 2.1 APIRequest 协议使用
- 所有网络请求必须实现 `APIRequest` 协议
- 明确设置 `allowsWeakNetwork` 属性以控制弱网环境下的请求行为
- 合理设置 `needsLoadingIndicator` 属性

### 2.2 错误处理
- 必须处理所有可能的网络错误类型
- 提供用户友好的错误信息
- 对于可恢复的错误，提供重试机制

### 2.3 请求配置
- 合理设置超时时间，避免过短或过长
- 正确配置请求头信息
- 敏感信息（如认证令牌）不应硬编码在代码中

## 3. 弱网处理规则

### 3.1 网络状态检测
- 使用 `ReachabilityManager` 检测网络状态
- 根据网络质量调整应用行为
- 在网络状态变化时及时更新 UI

### 3.2 请求策略
- 区分关键请求和非关键请求
- 关键请求在网络不可用时应提示用户
- 非关键请求可使用缓存数据或延迟发送

### 3.3 用户体验
- 在弱网环境下提供明确的用户提示
- 合理使用加载指示器，避免频繁闪烁
- 提供离线功能或缓存数据展示

## 4. 缓存管理规则

### 4.1 缓存策略
- 合理设置缓存过期时间
- 区分内存缓存和磁盘缓存的使用场景
- 定期清理过期缓存，避免占用过多存储空间

### 4.2 缓存一致性
- 确保缓存数据与服务器数据的一致性
- 在数据更新时及时清除相关缓存
- 提供缓存刷新机制

## 5. 安全规则

### 5.1 数据传输安全
- 所有网络请求必须使用 HTTPS
- 敏感数据传输时应进行加密
- 验证服务器证书，防止中间人攻击

### 5.2 数据存储安全
- 不在本地存储明文敏感信息
- 使用 Keychain 等安全存储机制
- 定期清理临时数据

### 5.3 凭证管理安全
- 绝不在代码、配置文件、日志或聊天中明文分享用户名、密码或访问令牌
- 使用环境变量或安全的密钥管理服务来存储敏感信息
- 定期轮换访问令牌（建议每90天）
- 为令牌设置适当的权限范围（最小权限原则）和过期时间
- 发现令牌泄露时立即撤销并生成新令牌
- 启用双重认证（2FA）保护账户安全
- 使用SSH密钥而非用户名/密码进行Git操作（推荐）

## 6. 性能优化规则

### 6.1 网络性能
- 合理使用连接池
- 避免重复请求相同数据
- 使用批量请求减少网络延迟

### 6.2 内存管理
- 及时释放不需要的资源
- 避免循环引用
- 使用弱引用处理代理和闭包

## 7. 测试规则

### 7.1 单元测试
- 所有公共接口必须有单元测试覆盖
- 测试用例应覆盖正常流程和异常流程
- 使用模拟对象隔离外部依赖

### 7.2 集成测试
- 关键业务流程必须有集成测试
- 测试不同网络环境下的表现
- 验证错误处理机制

## 8. 版本控制规则

### 8.1 提交信息规范
- 使用清晰、简洁的提交信息
- 遵循约定式提交格式
- 每次提交只包含相关的变更

### 8.2 分支管理
- 使用功能分支进行开发
- 定期同步主分支的变更
- 通过 Pull Request 进行代码审查

## 9. 文档规则

### 9.1 代码文档
- 所有公共 API 必须有详细的文档注释
- 提供使用示例
- 及时更新过时的文档

### 9.2 项目文档
- 重要设计决策应记录在文档中
- 更新 CHANGELOG 记录变更历史
- 提供清晰的入门指南

## 10. 常见问题避免规则

### 10.1 编译问题
- 定期检查并解决编译警告
- 确保所有依赖库版本兼容
- 避免引入不必要的依赖

### 10.2 运行时问题
- 处理所有可能的异常情况
- 避免在主线程进行网络请求
- 正确处理异步操作的生命周期

### 10.3 兼容性问题
- 测试不同系统版本的兼容性
- 遵循平台设计规范
- 处理不同设备屏幕尺寸的适配

## 11. 网络代理规则

### 11.1 代理设置
- 在执行需要网络访问的命令前，如遇到网络问题，可添加代理设置：
  ```bash
  export https_proxy=http://127.0.0.1:1087;export http_proxy=http://127.0.0.1:1087
  ```
- 代理设置应根据实际环境进行配置
- 在团队开发中统一代理配置，避免因网络环境不同导致的问题

## 12. iOS 示例构建规则

### 12.1 构建命令
- iOS 示例应用使用标准的 xcodebuild 命令进行构建：
  ```bash
  xcodebuild -scheme iOSExample -destination 'platform=iOS Simulator,name=iPhone 16,OS=18.6' build
  ```
- 构建前确保所有依赖已正确解析
- 根据实际开发环境调整设备名称和系统版本

### 12.2 构建环境
- 确保 Xcode 版本与项目要求一致
- 定期更新 CocoaPods 或 Swift Package Manager 依赖
- 在构建失败时检查系统环境和证书配置

## 13. 依赖管理规则

### 13.1 CocoaPods 使用
- 使用 CocoaPods 时，确保 Podfile 中指定明确的版本号范围
- 定期更新依赖库以获取安全补丁和新功能
- 使用 `pod update` 命令更新依赖时要谨慎，确保不会破坏现有功能
- 提交代码时包含更新后的 Podfile.lock 文件

### 13.2 Swift Package Manager 使用
- 优先使用 Swift Package Manager 作为依赖管理工具
- 在 Package.swift 中指定明确的依赖版本范围
- 定期检查和更新依赖项

### 13.3 依赖兼容性
- 确保所有依赖库与项目支持的最低系统版本兼容
- 避免引入功能重叠的多个依赖库
- 定期审查依赖库的安全性和维护状态

## 14. iOSExample 项目规则

### 14.1 依赖管理
- iOSExample 项目使用 CocoaPods 进行依赖管理
- 不再使用 Swift Package Manager 管理 iOSExample 的依赖
- 通过本地路径引用 FMNetCore 库：
  ```ruby
  pod 'FMNetCore', :path => '../../'
  ```

### 14.2 构建和运行
- 使用 `pod install` 安装依赖后，打开 `iOSExample.xcworkspace` 而不是 `iOSExample.xcodeproj`
- 确保在运行示例前已正确安装所有依赖
- 定期更新依赖以确保与主项目保持同步

### 14.3 项目结构
- iOSExample 项目应保持独立性，不依赖于主项目的 Package.swift
- 所有示例代码应直接引用 FMNetCore 模块，而不是通过 SPM

---
*本文档将持续更新，以反映项目开发过程中遇到的新问题和解决方案。*